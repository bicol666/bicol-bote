# 基于二进制位的权限管理设计

---

# 问题

随着`权限表`的数据增多，`角色权限联合表`中的数据变得非常大。

![image-20221114220545386](D:\bicol-note\Java\基于二进制的权限管理设计-img\image-20221114220545386.png)

于是诞生了一个解决方案，那就是使用`二进制比特位`来做权限管理。



# 关于字段、属性的数据类型选择

先说说单位换算：每个字节等于8个`比特位`。在`MySQL`当中最大的整数类型是`BIGINT`，能存储**8**个字节范围的数字。在`JAVA`程序中可以采用`BigInteger`来表示很大范围的数字，这个范围远远超过8个字节。但是受限于`MySQL`的最大数据类型是`BIGINT`，所以`JAVA`中只能采用也存储**8**个字节的`long`类型。



# 设计原理

| 二进制 | 十进制 |
| ------ | ------ |
| 0001   | 1      |
| 0010   | 2      |
| 0100   | 4      |
| 1000   | 8      |

假设用户有`0001`、`0010`、`1000`这三个用二进制表示的`权限码`。那么我们就可以用这几个权限码的`总和`来代表用户的`所有权限`：

`0001 （1）` |  `0010 （2）` |  `1000 （8）` =  `1011（11）`



**判断是否拥有权限**：只需要将`权限总和`与要判断的权限码进行与（&）运算，得出的结果**大于0**表示有这个权限，**等于0**表示没有权限。

> 假设我们要判断是否拥有权限码为`0010（2）`的权限：`1011` & `0010` =  `0010` >  0 （有权限） 
>
> 假设我们要判断是否拥有权限码为`0100（4）`的权限：`1011` & `0100` =  `0000`  = 0 （没有权限） 



**添加权限**：或（|）运算



**删除权限**：异或（^）运算



# 弊端

从上面关于`关于字段、属性的数据类型选择`、`设计原理`这两部分内容的分析不难得出：MySQL和Java程序中一个字段/属性（无符号）**最多只能**表示`64`种权限。

> 可能会有这样的疑问：一个无符号字段存储8个字节，那么表述范围不应该是：[0 - 2<sup>64</sup> - 1 ]这么大吗，为啥是64呢？是因为在[0 - 2<sup>64</sup> - 1 ]这个范围中，只有唯一一个比特位是`1`，其余比特位均是`0`的情况才能用来当做`权限码`。所以在无符号的情况下**有多少个比特位就能表示多少种权限**。
>
> 举个例子：假设有4个比特位，最多能表示多少种权限呢？很容易得出只有：`1000`、`0100`、`0010`、`0001`这四种情况可以表示权限，其余情况像：`1100`、`1110`、`1111`这种是不能用来当做权限码的，因为它们在**多个**比特位上**都是1**。有点烧脑，自行理解。



# 解决办法

**角色权限联合表**

| 字段        | 数据类型             | 说明               |
| ----------- | -------------------- | ------------------ |
| role_id     | `bigint`（unsigned） | 角色ID             |
| group_index | `int`（unsigned）    | 权限组索引         |
| permissions | `varchar`（64）      | 权限组所有权限总和 |



**权限表**

| 字段        | 数据类型          | 说明         |
| ----------- | ----------------- | ------------ |
| bit_code    | `varchar`（64）   | 权限二进制码 |
| group_index | `int`（unsigned） | 权限组索引   |



![image-20221114222919501](D:\bicol-note\Java\基于二进制的权限管理设计-img\image-20221114222919501.png)

`角色权限联合表`的一条记录对应角色一个权限组的权限总和，角色所有的权限组按权限组索引排列起来就组成了一个角色最终所有的权限。